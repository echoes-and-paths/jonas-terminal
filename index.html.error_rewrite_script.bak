<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>terminal.echoesandpaths.blog</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      font-family: 'Courier New', Courier, monospace;
      overflow: hidden;
      color: #4AF626;
      animation: flicker 3s infinite;
      border-radius: 15px;
      box-shadow: 0 0 60px rgba(74, 246, 38, 0.15) inset;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.03) 0px,
        rgba(255, 255, 255, 0.03) 1px,
        transparent 1px,
        transparent 2px
      );
      animation: scanlines-pulse 2s infinite;
      z-index: 10;
      pointer-events: none;
    }
    @keyframes scanlines-pulse {
      0%, 100% { opacity: 0.05; }
      50% { opacity: 0.1; }
    }
    @keyframes flicker {
      0%, 19%, 21%, 23%, 25%, 54%, 100% { opacity: 1; }
      20%, 22%, 24%, 55% { opacity: 0.95; }
    }
    #startup, #terminal {
      position: absolute;
      top: 10vh;
      left: 5vw;
      width: 90vw;
      white-space: pre-wrap;
      font-size: 1.1rem;
      line-height: 1.75rem;
      z-index: 2;
      text-shadow: 0 0 5px #4AF626, 0 0 10px #4AF626, 0 0 20px #4AF626;
    }
    .cursor {
      display: inline-block;
      width: 10px;
      background: #4AF626;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }
    .glitch-bars {
      position: fixed;
      top: -100px;
      left: 0;
      width: 100%;
      height: 60px;
      background: linear-gradient(to bottom,
        rgba(74, 246, 38, 0.4) 0%,
        rgba(74, 246, 38, 0.15) 50%,
        transparent 100%
      );
      z-index: 8;
      pointer-events: none;
      animation: glitchRoll 8s infinite ease-in-out;
    }
    @keyframes glitchRoll {
      0%, 95%, 100% { transform: translateY(-120%); opacity: 0; }
      45% { transform: translateY(100vh); opacity: 0.3; }
      46% { opacity: 0; }
    }
    .glitch-char {
      display: inline-block;
      animation: glitchChar 4s infinite steps(1, end);
    }
    @keyframes glitchChar {
      0%, 98%, 100% { opacity: 1; transform: none; filter: none; }
      2% {
        opacity: 0.6;
        transform: scaleX(1.3) skewX(10deg);
        filter: blur(1px);
      }
      3% {
        transform: scaleX(0.9) skewX(-5deg);
        filter: contrast(200%);
      }
    }
    .jonas-hint {
      opacity: 0.05;
      font-style: italic;
      padding-left: 28ch; /* For prompt alignment */
    }
  </style>
</head>
<body>
  <div id="startup">
> SYSTEM LINK :: <span class="glitch-char">CORRUPTED</span> MEMORY SECTOR ACCESS<br/>
> ARCHIVE FILE RECOVERY INTERFACE v7.1<br/><br/>
    <span id="errorMessage" style="color: #FF5555; display: block; min-height: 1.5rem;"></span>
> Enter archive file name: <span id="typed"></span><span class="cursor">&nbsp;</span><br/>
<span class="jonas-hint">jonas</span>
  </div>
  <div id="terminal" style="display:none;">
// fragment log: node -- 0345.delta.vermillion<br/>
// signal echo: jonas.hevel://witness/anomaly_004c<br/>
<span class="excerpt glitch-char">// transcribed excerpt: "...they kept it quiet, buried under the first failures..."</span><br/>
<span class="excerpt glitch-char">// transcribed excerpt: "...I only remember the humming—then the static..."</span><br/>
// audio signal type: async.packetstream.96kb.quiet-core<br/>
<div id="audioStatus"></div>
<div id="endPrompt"></div>
  </div>
  <div class="glitch-bars"></div>
  <audio id="hevelAudio" src="public/jonas_hevel_audio.mp3"></audio>
  <script>
    const errorMessageEl = document.getElementById("errorMessage");
    const volumeLevels = [0.2, 0.5, 0.9]; // Low, Medium, High
    const volumeNames = ["Low", "Medium", "High"];
    let currentVolumeIndex = 1; // Start at Medium
    const audio = document.getElementById('hevelAudio');
    const startup = document.getElementById('startup');
    const terminal = document.getElementById('terminal');
    const typed = document.getElementById('typed');
    const audioStatus = document.getElementById('audioStatus');
    const endPrompt = document.getElementById('endPrompt');
    const excerpts = [
      '"…they kept it quiet, buried under the first failures…"','"…I only remember the humming—then the static…"','"…we weren’t meant to hear this again…"','"…they called it recursion loss, whatever that means…"','"…he said the name before everything fell silent…"'
    ];
    let inputBuffer = "";
    let playbackStarted = false;
    function updateExcerpts() {
      document.querySelectorAll(".excerpt").forEach(el => {
        el.textContent = "// transcribed excerpt: " + excerpts[Math.floor(Math.random() * excerpts.length)];
      });
    }
    function formatTime(s) {
      const m = Math.floor(s / 60).toString().padStart(2, '0');
      const sec = Math.floor(s % 60).toString().padStart(2, '0');
      return `${m}:${sec}`;
    }
    function monitorAudio() {
      const duration = audio.duration || 200;
      const interval = setInterval(() => {
        if (audio.paused || audio.ended) { clearInterval(interval); return; }
        audioStatus.textContent = `-- time: ${formatTime(audio.currentTime)} / ${formatTime(duration)}`;
      }, 1000);
    }
    function handlePlaybackEnd() {
      endPrompt.innerHTML = `>> end of audio signal<br/>play again? (y/n)`;
      document.addEventListener("keydown", function handler(e) {
        if (e.key === "y") {
          endPrompt.innerHTML = "";
          updateExcerpts();
          setInitialAudioSettings();
          audio.play();
          monitorAudio();
          document.removeEventListener("keydown", handler);
        } else if (e.key === "n") {
          endPrompt.innerHTML = `>> link closed.`;
          document.removeEventListener("keydown", handler);
        }
      });
    }
    function setInitialAudioSettings() {
    // audio.volume = 0.85 + Math.random() * 0.15; // This was the OLD LINE
    audio.volume = volumeLevels[currentVolumeIndex]; // NEW: Set to current selected level
    }
    function showCommands() {
      endPrompt.innerHTML += `<br/>> commands: p = pause/play, r = rewind 10s, f = forward 10s, v = volume, q = quit`;
    }
    audio.addEventListener("ended", handlePlaybackEnd);
    document.addEventListener("keydown", (e) => {
      if (!playbackStarted) {
        if (e.key.length === 1 && /^[a-zA-Z0-9]$/.test(e.key)) {
          inputBuffer += e.key.toLowerCase();
          typed.textContent = inputBuffer;
        } else if (e.key === "Backspace") {
          inputBuffer = inputBuffer.slice(0, -1);
          typed.textContent = inputBuffer;
        }
        if (inputBuffer === "jonas") {
          startup.style.display = "none";
          terminal.style.display = "block";
          playbackStarted = true;
          updateExcerpts();
           setInitialAudioSettings();
          audio.play();
          monitorAudio();
          setInterval(updateExcerpts, 6000);
          showCommands();
        }
      } else {
        if (e.key === "p") audio.paused ? audio.play() : audio.pause();
        if (e.key === "r") audio.currentTime = Math.max(audio.currentTime - 10, 0);
        if (e.key === "f") audio.currentTime = Math.min(audio.currentTime + 10, audio.duration);
    if (e.key === "v") { // NEW LOGIC for cycling 'v'
      currentVolumeIndex = (currentVolumeIndex + 1) % volumeLevels.length;
      audio.volume = volumeLevels[currentVolumeIndex];
      audioStatus.textContent = `-- volume: ${volumeNames[currentVolumeIndex]} (${(audio.volume * 100).toFixed(0)}%)`;
    }
        if (e.key === "q") {
          audio.pause();
          audio.currentTime = 0;
          endPrompt.innerHTML = `>> playback terminated.`;
        }
      }
    });
  </script>
</body>
</html>
